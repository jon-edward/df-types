from textwrap import indent

from df_types.config import DFTypesConfig
from df_types._infer import InferredTypeNames, InferredLiterals


_HEADER = """
# This file was generated by df-types

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING
""".lstrip()


def _format_long_dict(d: dict[str, str], max_len: int, indent: int = 4) -> str:
    if len(repr(d)) < max_len:
        return repr(d)
    return _format_dict_multiline(d, indent)


def _format_dict_multiline(d: dict, indent: int = 4) -> str:
    """Format a dictionary across multiple lines with indentation."""
    inner_indent = " " * (indent + 4)
    items = f", \n{inner_indent}".join(f"{k!r}: {v!r}" for k, v in d.items())
    return f"{{\n{inner_indent}{items}\n{' ' * indent}}}"


def _format_imports(type_names: set[tuple[str, str]]) -> str:
    return _join_import_lines(type_names)


def _join_import_lines(type_names: set[tuple[str, str]]) -> str:
    """Join import lines for a set of (module, name) tuples."""
    return "\n".join(
        f"from {module} import {name}" for module, name in type_names if module
    )


def _format_dataclass(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    config: DFTypesConfig,
) -> str:
    class_name = _validate_class_name(config.class_name)
    content = _format_dataclass_header(class_name, config.use_slots)
    imports = set()
    content += _format_dataclass_fields(col_to_attr_names, types, imports)
    return _format_type_checking_imports(imports) + "\n\n\n" + content


def _validate_class_name(class_name: str) -> str:
    class_name = class_name.strip()
    if (
        not class_name
        or class_name[0].isdigit()
        or not class_name.replace("_", "").isalnum()
    ):
        raise ValueError(f"Invalid class name: {class_name}")
    return class_name


def _format_dataclass_header(class_name: str, use_slots: bool) -> str:
    return f"@dataclass{f'(slots=True)' if use_slots else ''}\nclass {class_name}:\n"


def _format_dataclass_fields(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    imports: set[tuple[str, str]],
) -> str:
    lines = []
    for attr_name, type_ in types.items():
        attr_name = col_to_attr_names.get(attr_name, attr_name)
        if isinstance(type_, InferredTypeNames):
            imports.update(type_.type_names)
            lines.append(_format_type_names_field(attr_name, type_))
        else:
            imports.add(("typing", "Literal"))
            lines.append(_format_literal_field(attr_name, type_))
    return "".join(lines)


def _format_type_names_field(attr_name: str, type_: InferredTypeNames) -> str:
    type_str = " | ".join(name for _, name in type_.type_names)
    if type_.contains_nans:
        type_str += " | None"
    return f"    {attr_name}: {type_str}\n"


def _format_literal_field(attr_name: str, type_: InferredLiterals) -> str:
    literals = ", ".join(type_.literal_reprs)
    return f"    {attr_name}: Literal[{literals}]\n"


def _format_type_checking_imports(imports: set[tuple[str, str]]) -> str:
    if not imports:
        return ""
    return "if TYPE_CHECKING:\n" + indent(_format_imports(imports), "    ")


def _format_col_to_attr_names_method(col_to_attr_names: dict[str, str]) -> str:
    return indent(
        f"def col_to_attr_names(self) -> dict[str, str]:\n    return {_format_long_dict(col_to_attr_names, 80)}",
        "    ",
    )


def generate_types(
    col_to_attr_names: dict[str, str],
    types: dict[str, InferredTypeNames | InferredLiterals],
    config: DFTypesConfig,
) -> str:
    """
    Generate the type definitions for a DataFrame
    """
    content = _HEADER
    return (
        content
        + "\n\n"
        + _format_dataclass(col_to_attr_names, types, config)
        + "\n"
        + _format_col_to_attr_names_method(col_to_attr_names)
        + "\n"
    )
